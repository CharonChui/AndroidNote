强引用、软引用、弱引用、虚引用
===

- 强引用(Strong Reference)
    平时我们编程的时候例如：`Object object=new Object()`；那`object`就是一个强引用了。如果一个对象具有强引用，那就类似于必不可少的生活用品，
	垃圾回收器绝不会回收它。当内存空 间不足，`Java`虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

- 软引用(SoftReference)
    如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
    只要垃圾回收器没有回收它，该对象就可以被程序使用。**软引用可用来实现内存敏感的高速缓存**。 软引用可以和一个引用队列`(ReferenceQueue)`联合使用，
    如果软引用所引用的对象被垃圾回收，`Java`虚拟机就会把这个软引用加入到与之关联的引用队列中。

- 弱引用(WeakReference)
    弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
    弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器 
    弱引用可以和一个引用队列`(ReferenceQueue)`联合使用，如果弱引用所引用的对象被垃圾回收,`Java`虚拟机就会把这个弱引用加入到与之关联的引用队列中。 
	

- 虚引用(PhantomReference)   
    "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，
    那么它就和没有任何引用一样，在 任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：
    虚引用必须和引用队列 `(ReferenceQueue)`联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，
    把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
    程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。
    虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。
    虚引用主要用于检测对象是否已经从内存中删除。
    
	
有关弱引用以及软引用再分析一下:
我们都知道垃圾回收器会回收符合回收条件的对象的内存，但并不是所有的程序员都知道回收条件取决于指向该对象的引用类型。这正是`Java`中弱引用和软引用的主要区别。
如果一个对象只有弱引用指向它，垃圾回收器会立即回收该对象，这是一种急切回收方式。相对的，如果有软引用指向这些对象，则只有在`JVM`需要内存时才回收这些对象。
弱引用和软引用的特殊行为使得它们在某些情况下非常有用。例如：软引用可以很好的用来实现缓存，当`JVM`需要内存时，垃圾回收器就会回收这些只有被软引用指向的对象。
而弱引用非常适合存储元数据，例如：存储`ClassLoader`引用。如果没有类被加载，那么也没有指向`ClassLoader`的引用。一旦上一次的强引用被去除，
只有弱引用的`ClassLoader`就会被回收。

---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
