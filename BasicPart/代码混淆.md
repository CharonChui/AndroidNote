代码混淆
===

混淆器(ProGuard)
---

混淆器通过删除从未用过的代码和使用晦涩名字重命名类、字段和方法，对代码进行压缩，优化和混淆。

1. 修改project.properties
	```xml
	# This file is automatically generated by Android Tools.
	# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
	#
	# This file must be checked in Version Control Systems.
	#
	# To customize properties used by the Ant build system edit
	# "ant.properties", and override values to adapt the script to your
	# project structure.
	#
	# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
	#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt

	# Project target.
	target=android-19
	```
    将proguard.config前面的注释去掉

2. 修改proguard-project.txt
	```xml
	# To enable ProGuard in your project, edit project.properties
	# to define the proguard.config property as described in that file.
	#
	# Add project specific ProGuard rules here.
	# By default, the flags in this file are appended to flags specified
	# in ${sdk.dir}/tools/proguard/proguard-android.txt
	# You can edit the include path and order by changing the ProGuard
	# include property in project.properties.
	#
	# For more details, see
	#   http://developer.android.com/guide/developing/tools/proguard.html

	# Add any project specific keep options here:

	# If your project uses WebView with JS, uncomment the following
	# and specify the fully qualified class name to the JavaScript interface
	# class:
	#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
	#   public *;
	#}
	```
    如果在程序中使用了第三方的`jar`包，在混淆后导致出错，这时我们需要在proguard-project.txt中去进行相应的配置，
	来让其在混淆时不要混淆相应的jar包。对改配置文件中的相关配置解释如下：
	```java
	-keep public class * extends android.app.Activity　　【不进行混淆类名的类，保持其原类名和包名】

	-keep public abstract interface com.asqw.android.Listener{
	public protected <methods>;  【所有public protected的方法名不进行混淆】
	}
	-keep public class com.asqw.android{
	public void Start(java.lang.String); 【对该方法不进行混淆】
	}
	-keepclasseswithmembernames class * { 【对所有类的native方法名不进行混淆】
	native <methods>;
	}
	-keepclasseswithmembers class * { 【对所有类的指定方法的方法名不进行混淆】
	public <init>(android.content.Context, android.util.AttributeSet);
	}
	-keepclassmembers class * extends android.app.Activity {【对所有类的指定方法的方法名不进行混淆】
	public void *(android.view.View);
	}
	-keepclassmembers enum * {【对枚举类型enum的所有类的以下指定方法的方法名不进行混淆】
	public static **[] values();
	public static ** valueOf(java.lang.String);
	}
	-keep class * implements android.os.Parcelable {【对实现了Parcelable接口的所有类的类名不进行混淆，对其成员变量为Parcelable$Creator类型的成员变量的变量名不进行混淆】
	public static final android.os.Parcelable$Creator *;
	}
	-keepclasseswithmembers class org.jboss.netty.util.internal.LinkedTransferQueue {【对指定类的指定变量的变量名不进行混淆】
		volatile transient org.jboss.netty.util.internal.LinkedTransferQueue$Node head;
		volatile transient org.jboss.netty.util.internal.LinkedTransferQueue$Node tail;
		volatile transient int sweepVotes;

	}
	-keep public class com.unionpay.** {*; }【对com.unionpay包下所有的类都不进行混淆，即不混淆类名，也不混淆方法名和变量名】
	```        

	经过上面这两部之后反编译后就能混淆了，但是四大组件还在，为什么四大组件还在呢，因为四大组件是在清单文件中进行配置的，
	如果混淆后就不能根据清单文件的配置去寻找了。     
	如果对于一些自己的代码中要想提供出来让别人通过反射调用的方法时,我们不想让部分代码被混淆，或者是我们使用别人提供的第三方jar包，
	因为第三方的jar包一般都是已经混淆过的，我们要是再混淆就会报错了，所以我们要保证这些内容不用混淆，这里我们只需修改这个文件，然后加上后面的一句话，
	他就不会混淆我们给出的内容    
	```xml
	-keepattributes *Annotation*          
	-keep public class * extends android.app.Activity
	-keep public class * extends android.app.Application
	-keep public class * extends android.app.Service
	-keep public class * extends android.content.BroadcastReceiver
	-keep public class * extends android.content.ContentProvider
	-keep public class * extends android.app.backup.BackupAgent
	-keep public class * extends android.preference.Preference
	-keep public class * extends android.support.v4.app.Fragment
	-keep public class * extends android.app.Fragment
	-keep public class com.android.vending.licensing.ILicensingService
	-keep class net.youmi.android.** {
	*;
	}
	```
	
---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 

