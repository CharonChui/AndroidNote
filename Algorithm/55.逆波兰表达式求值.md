55.逆波兰表达式求值
===


### 题目

给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意:     

- 有效的算符为 '+'、'-'、'*' 和 '/' 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 向零截断 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 32 位 整数表示。
 

示例 1:    

- 输入：tokens = ["2","1","+","3","*"]
- 输出：9
- 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2:     

- 输入：tokens = ["4","13","5","/","+"]
- 输出：6
- 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3:    

- 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
- 输出：22
- 解释：该算式转化为常见的中缀算术表达式为:    
```
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
``` 

提示:   

- 1 <= tokens.length <= 104
- tokens[i]是一个算符（`+`、`-`、`*`或`/`），或是在范围`[-200, 200]`内的一个整数    
 

逆波兰表达式:     

- 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
- 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点:    

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

### 思路

逆波兰表达式，也叫做后缀表达式。

我们平时见到的运算表达式是中缀表达式，即 "操作数① 运算符② 操作数③" 的顺序，运算符在两个操作数中间。
但是后缀表达式是 "操作数① 操作数③ 运算符②" 的顺序，运算符在两个操作数之后。


逆波兰表达式严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作:     

- 如果遇到操作数，则将操作数入栈；

- 如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。

整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。


![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/leetcode_evalRPN1.png?raw=true)
![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/leetcode_evalRPN2.png?raw=true)
![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/leetcode_evalRPN3.png?raw=true)
![image](https://raw.githubusercontent.com/CharonChui/Pictures/master/leetcode_evalRPN4.png?raw=true)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = tokens.length;
        for (int i = 0; i < n; i++) {
            String token = tokens[i];
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }
        }
        return stack.pop();
    }

    public boolean isNumber(String token) {
        return !("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token));
    }
}
```

复杂度分析:      

- 时间复杂度: O(n)，其中 n 是数组 tokens 的长度。需要遍历数组 tokens 一次，计算逆波兰表达式的值。

- 空间复杂度: O(n)，其中 n 是数组 tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。


---
- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 

	
