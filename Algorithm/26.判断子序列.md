26.判断子序列
===


### 题目

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
 

示例 1:   

- 输入：s = "abc", t = "ahbgdc"
- 输出：true

示例 2:   

- 输入：s = "axc", t = "ahbgdc"
- 输出：false
 

提示:    

- 0 <= s.length <= 100
- 0 <= t.length <= 10^4
- 两个字符串都只由小写字符组成。

### 思路


首先，如果 s 是空串，直接返回 true，因为空串是任何字符串的子序列。  
设置双指针 i , j 分别指向字符串 s , t 的首个字符，遍历字符串 t:    

- 当 s[i] == t[j] 时，代表匹配成功，此时同时 i++ , j++ ；
    - 进而，若 i 已走过 s 尾部，代表 s 是 t 的子序列，此时应提前返回 true ；
- 当 s[i] != t[j] 时，代表匹配失败，此时仅 j++ ；

若遍历完字符串 t 后，字符串 s 仍未遍历完，代表 s 不是 t 的子序列，此时返回 false 。

```java

class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
}
```

复杂度分析:   

- 时间复杂度 O(N) ： 其中 N 为字符串 t 的长度。最差情况下需完整遍历 t 。
- 空间复杂度 O(1) ： i , j 变量使用常数大小空间。


##### 进阶问题解法

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？


这种类似对同一个长字符串做很多次匹配的 ，可以像 KMP 算法一样，先用一些时间将长字符串中的数据 提取出来，磨刀不误砍柴功。有了提取好的数据，就可以快速的进行匹配。

因为S非常多，所以可以通过一次性对T进行简化处理，这样来减少后续每一次S匹配T的遍历时间:     

- 这里需要的数据就是匹配到某一点时,待匹配的字符在长字符串中 下一次 出现的位置。

- 所以我们前期多做一点工作，将长字符串研究透彻，假如长字符串的长度为 n，建立一个 n∗26 大小的矩阵，表示每个位置上26个字符下一次出现的位置。实现如下：

- 对于要匹配的短字符串，遍历每一个字符，不断地寻找该字符在长字符串中的位置，然后将位置更新，寻找下一个字符，相当于在长字符串上“跳跃”。

- 如果下一个位置为 -1，表示长字符串再没有该字符了，返回 false 即可。

- 如果能正常遍历完毕，则表示可行，返回 true

- 需要注意的一点

    - 对于 "abc" 在 "ahbgdc" 上匹配的时候，由于长字符串第一个 a 的下一个出现 a 的位置为 -1（不出现），会导致一个 bug。

    - 所以在生成数组时在长字符串前插入一个空字符即可。

```java

//进阶问题的解决 
public boolean isSubsequence(String s, String t) {

    //考虑到  对第一个字符的处理 ，在t 之前一个空字符
    t=' '+t;

    //对t长字符串 做预处理
    int[][] dp = new int[t.length()][26];//存储每一个位置上  a--z的下一个字符出现的位置
    for (char c = 'a'; c <= 'z'; c++) {//依次对每个字符作处理
        int nextPos = -1;//表示接下来不会在出现该字符

        for (int i = t.length() - 1; i >= 0; i--) {//从最后一位开始处理
            dp[i][c - 'a'] = nextPos;//dp[i][c-'a']  加上外层循环  就是对每一个位置的a---z字符的处理了
            if (t.charAt(i) == c) {//表示当前位置有该字符  那么指向下一个该字符出现的位置就要被更新  为i
                nextPos = i;
            }
        }
    }

    //数据的利用 ，开始匹配
    int index=0;
    for (char c:s.toCharArray()){
        index=dp[index][c-'a'];//因为加了' '，所以之后在处理第一个字符的时候  如果是在第一行，就会去第一行，不影响之后字符的判断
        if(index==-1){
            return false;
        }
    }
    return true;
}
```

---
- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 

	
