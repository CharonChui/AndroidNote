强引用、软引用、弱引用、虚引用
===

在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。一般说来，如果物品已经被扔到垃圾箱，想再把它捡回来使用就不可能了。      
但有时候情况并不这么简单，你可能会遇到类似鸡肋一样的物品，食之无味，弃之可惜。这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些必不可少的生活用品，那么再扔掉这些可有可无的物品。     
从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。

***这四种级别由高到低依次为：强引用 > 软引用 > 弱引用 > 虚引用。***



![](https://raw.githubusercontent.com/CharonChui/Pictures/master/reference_list.jpg)

在java.lang.ref包中提供了三个类：SoftReference类、WeakReference类和PhantomReference类，它们分别代表软引用、弱引用和虚引用。ReferenceQueue类表示引用队列，它可以和这三种引用类联合使用，以便跟踪Java虚拟机回收所引用的对 象的活动。



- 强引用(Strong Reference)
  
    你懂的，不要胡乱持有着不放，不然内存泄露、oom有你好看，就像是老板（OOM）的亲儿子一样，在公司可以什么事都不干，但是千万不要老是占用公司的资源为他自己做事，记得用完公司的妹子之后,要让她们去工作(资源要懂得释放) 不然公司很可能会垮掉的。   

    平时我们编程的时候例如：`Object object=new Object()`；那`object`就是一个强引用了。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有强引用的存活着的对象！记住是存活着，不可能是你new一个对象就永远不会被GC回收。
  
- 软引用(SoftReference)
  
    描述一些还有用，但并非必需的对象。如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存，但是system.gc对其无效，有点像老板(OOM)的亲戚，在公司表现不好有可能会被开除，即使你投诉他（调用GC)上班看片，但是只要不被老板看到（被JVM检测到）就不会被开除（被虚拟机回收）。**软引用可用来实现内存敏感的高速缓存**。 软引用可以和一个引用队列`(ReferenceQueue)`联合使用，如果软引用所引用的对象被垃圾回收，`Java`虚拟机就会把这个软引用加入到与之关联的引用队列中。

- 弱引用(WeakReference)
  
    同软引用，也用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。所以弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的声明周期。在对象没有其他引用的情况下，调用system.gc对象可被虚拟机回收，就是一个普通的员工，平常如果表现不佳会被开除（对象没有其他引用的情况下），遇到别人投诉（调用GC)上班看片,那开除是肯定了(被虚拟机回收)。
    
    在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了***只具***有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。

    常见的一个例子就是WeakHashMap，在HashMap中，键被置为null，唤醒gc后，不会垃圾回收键为null的键值对。但是在WeakHashMap中，键被置为null，唤醒gc后，键为null的键值对会被回收。
    
    ```
    public static void weakHashMapTest() {
    	Integer key = new Integer(1);
    	String value = "李四";
    	Map<Integer,String> weakHashMap = new WeakHashMap();
    	weakHashMap.put(key, value);
    	System.out.println(weakHashMap);//{1=李四}
    	key = null;
    	System.gc();
    	System.out.println(weakHashMap);//{}
    }
    public static void hashMapTest() {
    	HashMap<Integer,String> map = new HashMap<>();
    	Integer key = 1;
    	String value = "张三";
    	map.put(key,value);
    	System.out.println(map);//{1=张三}
    	key = null;
    	System.gc();
        System.out.println(map);//{1=张三}
    }
    ```
    
- 虚引用(PhantomReference)   
  
    "虚引用"顾名思义，就是形同虚设，也成为幽灵引用或幻影引用，它是最弱的一种引用关系。就只是一个标识，对象的生命周期不受期影响，这货估计就是个临时工把，遇到事情的时候想到了你，没有事情的时候，秒秒钟拿出去顶锅，开除。
    
    一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一的用处：能在对象被GC时收到系统通知，主要用于跟踪对象何时被回收，比如防止资源泄漏等。 
    
    虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null。

![](https://raw.githubusercontent.com/CharonChui/Pictures/master/reference_compare.jpg)


无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。


在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(Strongly Re-ference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。


- 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。

- 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。

- 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
