## 13.实例化

实例化(instancing)提供了一种机制，可以只用一个C++/OpenGL调用就告诉显卡渲染一个对象的多个副本。这可以带来显著的性能优势，特别是在绘制有数千甚至数百万个对象时，例如渲染在场地中的许多花朵。

实例化最常见的应用就是做一些粒子效果，例如一些烟花的效果。。


在渲染多个对象时，OpenGL使用Z-buffer算法来进行隐藏面消除。通常情况下，通过选择最接近相机的相应片段的颜色作为像素的颜色，这种方法可决定哪些物体的曲面可见并呈现到屏幕，而位于其他物体后面的曲面不应该被渲染。
然而，有时候场景中的两个物体表面重叠并位于重合的平面中，这使得深度缓冲区算法难以确定应该渲染两个表面中的哪一个（因为两者都不“最接近”相机）。发生这种情况时，浮点舍入误差可能会导致渲染表面的某些部分使用其中一个对象的颜色，而其他部分则使用另一个对象的颜色。这种不自然的伪影称为Z冲突(Z-fighting)或深度冲突(depth-fighting)，是渲染的片段在深度缓冲区中相互对应的像素条目上“斗争”的结果。


![image](https://github.com/CharonChui/Pictures/blob/master/opengl_z_fighting.png?raw=true)



提高渲染效率的另一种方法是利用OpenGL的背面剔除能力。当3D模型完全“闭合”时，意味着内部永远不可见（例如对于立方体和四棱锥），那么外表面的那些与观察者背离且呈一定角度的部分将始终被同一模型的其他部分遮挡。也就是说，那些背离观察者的三角形不可能被看到（无论如何它们都会在隐藏面消除的过程中被覆盖），因此没有理由栅格化或渲染它们。
我们可以使用命令glEnable(GL_CULL_FACE)要求OpenGL识别并“剔除”（不渲染）背向的三角形。我们还可以使用glDisable(GL_CULL_FACE)禁用背面剔除。默认情况下，背面剔除是关闭的，因此如果你希望OpenGL剔除背向三角形，必须手动启用它。




--- 
[上一篇: 13.LUT滤镜](https://github.com/CharonChui/AndroidNote/blob/master/VideoDevelopment/OpenGL/13.LUT%E6%BB%A4%E9%95%9C.md)

---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 































